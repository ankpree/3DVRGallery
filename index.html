<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Antique Exhibition</title>

        <!-- Babylon.js -->
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylon.objFileLoader.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id="renderCanvas"></canvas>
        <script>
            var canvas = document.getElementById("renderCanvas");
            var engine = null;
            var scene = null;
            var sceneToRender = null;
            var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
            var createScene = async function () {
                // This creates a basic Babylon Scene object (non-mesh)
                var scene = new BABYLON.Scene(engine);
                /////////////////////////////
                /////DEFINING VARIABLES//////
                /////////////////////////////
                var groundList =[];
                var maxScale =10;//this value defines crosshair scale
                var minScale =1;//this value defines crosshair scale
                var maxDistance =15;//this value defines crosshair distance ranges
                var minDistance =.1;//this value defines crosshair distance ranges
                var factor=1;//factor to scale crosshair
                var movingAction = false;// This defines if the user is looking to move to a new position
                var emptyMesh =BABYLON.MeshBuilder.CreateBox("emptyBox",{size:1},scene);
                emptyMesh.position = new BABYLON.Vector3(0,500,0);
                var trackingMesh;
                var pointerPos = new BABYLON.Vector2();//empty position vector
                /////////////////////////////
                // This creates and positions a free camera (non-mesh)
                var camera = new BABYLON.DeviceOrientationCamera("camera1", new BABYLON.Vector3(0,3,-10), scene);
                // This targets the camera to scene origin
                camera.setTarget(new BABYLON.Vector3(0,3,0));
                // This attaches the camera to the canvas
                camera.attachControl(canvas, true);
                camera.invertRotation =true;
                camera.fov = 1.0;
                camera.minZ =0.01;
                ////////////////////////////////
                //MouseWheelZoom////////////////
                ////////////////////////////////
                //Default camera fov is 1;
                fov_min = 0.5;
                fov_max = 1.0;
                var zoomedIn =false;
                scene.onPointerObservable.add((pointerInfo) => {
		            switch (pointerInfo.type) {
			            case BABYLON.PointerEventTypes.POINTERDOUBLETAP:
				            console.log("POINTER DOUBLE-TAP");
                            if(!zoomedIn){
                                camera.fov = fov_min;
                                zoomedIn =true;
                            } else {
                                camera.fov = fov_max;
                                zoomedIn =false;
                            }
				            break;
                    }
                });
                scene.onPrePointerObservable.add( function(pointerInfo, eventState)
                {
                var event = pointerInfo.event;
                var delta = 0;
                if (event.wheelDelta) {
                    delta = event.wheelDelta;
                }
                else if (event.detail) {
                    delta = -event.detail;
                }
                delta = Math.max(-1, Math.min(1, delta));
                delta *= -1;
                if (delta) {
                    camera.fov += delta/20;
                    camera.fov = Math.max(fov_min, Math.min(fov_max, camera.fov));
                }
                if(camera.fov == fov_min){
                    zoomedIn =true;
                }
                if(camera.fov == fov_max){
                    zoomedIn =false;
                }
                });
                //--------------//
                ///////////
                //LIGHTS///
                ///////////
                var lightD = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(1, 1, 1), scene);
                lightD.intensity =.1;
                var lightD2 = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(-1, -1, -1), scene);
                lightD2.intensity =.1;
                var light1 = new BABYLON.PointLight("pointLight",new BABYLON.Vector3(0,8,0));
                light1.intensity =1;
                //////////////
                //SHADOWS/////
                //////////////
                //const shadowGen = new BABYLON.ShadowGenerator(1024,light1);
                ///////////
                //////////////
                //MATERIALS///
                //////////////
                var alphaMaterial = .001;
                var groundZeroMaterial = new BABYLON.StandardMaterial("groundZeroMaterial",scene);
                groundZeroMaterial.diffuseColor =new BABYLON.Color3(.9, .9, .9); 
                groundZeroMaterial.specularColor = new BABYLON.Color3(0,0,0); 
                groundZeroMaterial.alpha = alphaMaterial;
                var groundMaterial = new BABYLON.StandardMaterial("groundMaterial",scene);
                groundMaterial.diffuseColor = new BABYLON.Color3(.6,.2,.2); 
                groundMaterial.specularColor = new BABYLON.Color3(0,0,0); 
                groundMaterial.alpha =alphaMaterial;
                var wallMaterial = new BABYLON.StandardMaterial("wallMaterial",scene);
                wallMaterial.diffuseColor = new BABYLON.Color3(0.71, 0.82, 1);
                wallMaterial.specularColor = new BABYLON.Color3(0,0,0);
                wallMaterial.alpha = alphaMaterial;
                var roofMaterial = new BABYLON.StandardMaterial("roofMaterial",scene);
                roofMaterial.diffuseColor = new BABYLON.Color3(0.9, .8, 0.64);
                roofMaterial.specularColor = new BABYLON.Color3(0,0,0);
                roofMaterial.alpha =alphaMaterial;
                var woodMaterial = new BABYLON.StandardMaterial("woodMaterial",scene);
                woodMaterial.diffuseColor = new BABYLON.Color3(0.58, .3, 0);
                woodMaterial.specularColor = new BABYLON.Color3(0,0,0);
                woodMaterial.alpha =alphaMaterial;
                var transparentMaterial = new BABYLON.StandardMaterial("transparentMaterial",scene);
                transparentMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                transparentMaterial.specularColor = new BABYLON.Color3(0,0,0);
                transparentMaterial.alpha =.95;
                //--------------//
                ///////////////////
                //UI Disclaimer////
                ///////////////////
                var advancedTextureFullScreen = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                var disclaimerText = new BABYLON.GUI.TextBlock();
                disclaimerText.width = "600px"
                disclaimerText.height = "40px";
                disclaimerText.textHorizontalAlignment = 0;
                disclaimerText.text = "This demo is for internal use and testing purpose only."
                disclaimerText.fontWeight = "bold";
                disclaimerText.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                disclaimerText.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                advancedTextureFullScreen.addControl(disclaimerText);
                //////////////////
                //BG music UI/////
                //////////////////
                //Add BG music here//
                var bgm = new BABYLON.Sound("BGM", "Content/Common/BGM.mp3", scene, null, {
                    loop: true,
                    autoplay: false
                });
                let playBGM = function(){
                    bgm.play();
                }
                let stopBGM = function(){
                    bgm.stop();
                }
                //////////////////////
                var buttonBGM_ON = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonBGM_ON",
                    "Content/Common/buttonBGM_ON.png"
                ); 
                buttonBGM_ON.leftInPixels =-150;
                buttonBGM_ON.widthInPixels = 50;
                buttonBGM_ON.heightInPixels = 50;
                buttonBGM_ON.thickness =0;
                buttonBGM_ON.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_RIGHT;
                buttonBGM_ON.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                advancedTextureFullScreen.addControl(buttonBGM_ON);
                var buttonBGM_OFF = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonBGM_OFF",
                    "Content/Common/buttonBGM_OFF.png"
                ); 
                buttonBGM_OFF.leftInPixels =-150;
                buttonBGM_OFF.widthInPixels = 50;
                buttonBGM_OFF.heightInPixels = 50;
                buttonBGM_OFF.thickness =0;
                buttonBGM_OFF.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_RIGHT;
                buttonBGM_OFF.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                buttonBGM_ON.onPointerClickObservable.add((evt) =>{
                    buttonBGM_OFF.isVisible =true;
                    buttonBGM_ON.isVisible =false;
                    stopBGM(); 
                })
                buttonBGM_OFF.onPointerClickObservable.add((evt) =>{
                    buttonBGM_ON.isVisible =true;
                    buttonBGM_OFF.isVisible =false;
                    playBGM(); 
                })
                advancedTextureFullScreen.addControl(buttonBGM_OFF);
                ///////////////////////////////
                // Floorplan movement UI///////
                ///////////////////////////////
                let playerWidth = 15;
                let playerHeight = 15;
                let floorWidth = 150;
                let floorHeight = 150;
                let telportableWidth = 26;
                let telportableHeight = 26;
                let conversionFactor = floorWidth/telportableWidth;
                let factorX = -floorWidth  + (conversionFactor*telportableWidth/2)-(playerWidth/2);
                let factorY = floorHeight  - (conversionFactor*telportableHeight/2)+(playerHeight/2);
                let floorLayoutImage = new BABYLON.GUI.Image("floorLayoutImage","Content/Common/floorLayout.png");
                floorLayoutImage.widthInPixels = floorWidth;
                floorLayoutImage.heightInPixels = floorHeight;
                floorLayoutImage.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_RIGHT;
                floorLayoutImage.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                advancedTextureFullScreen.addControl(floorLayoutImage);
                let playerIndicator = new BABYLON.GUI.Image("playerIndicator","Content/Common/playerIndicator.png");
                playerIndicator.widthInPixels = playerWidth;
                playerIndicator.heightInPixels = playerHeight;
                playerIndicator.leftInPixels = factorX + playerIndicator.widthInPixels+camera.position.x*conversionFactor;
                playerIndicator.topInPixels = factorY - playerIndicator.heightInPixels-camera.position.z*conversionFactor;
                playerIndicator.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_RIGHT;
                playerIndicator.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                advancedTextureFullScreen.addControl(playerIndicator);
                ////////////////////////
                // GT MENU /////////////
                ////////////////////////
                var gtMenuPanel = new BABYLON.GUI.Container();
                gtMenuPanel.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                gtMenuPanel.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_BOTTOM;
                gtMenuPanel.width = "500px";
                gtMenuPanel.height = "80px";
                var buttonGTmenu = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenu",
                    "Content/Common/gtMenu.png"
                ); 
                buttonGTmenu.widthInPixels = 50;
                buttonGTmenu.heightInPixels = 50;
                buttonGTmenu.thickness =0;
                buttonGTmenu.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenu.leftInPixels =0;
                gtMenuPanel.addControl(buttonGTmenu);
                var buttonGTmenuClose = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuClose",
                    "Content/Common/gtMenuClose.png"
                ); 
                buttonGTmenuClose.widthInPixels = 50;
                buttonGTmenuClose.heightInPixels = 50;
                buttonGTmenuClose.thickness =0;
                buttonGTmenuClose.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuClose.leftInPixels =0;
                gtMenuPanel.addControl(buttonGTmenuClose);
                var buttonGTmenuPlay = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuPlay",
                    "Content/Common/gtMenuPlay.png"
                ); 
                buttonGTmenuPlay.widthInPixels = 50;
                buttonGTmenuPlay.heightInPixels = 50;
                buttonGTmenuPlay.thickness =0;
                buttonGTmenuPlay.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuPlay.leftInPixels =60;
                gtMenuPanel.addControl(buttonGTmenuPlay);
                var buttonGTmenuPause = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuPause",
                    "Content/Common/gtMenuPause.png"
                ); 
                buttonGTmenuPause.widthInPixels = 50;
                buttonGTmenuPause.heightInPixels = 50;
                buttonGTmenuPause.thickness =0;
                buttonGTmenuPause.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuPause.leftInPixels =60;
                gtMenuPanel.addControl(buttonGTmenuPause);
                var buttonGTmenuStop = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuStop",
                    "Content/Common/gtMenuStop.png"
                ); 
                buttonGTmenuStop.widthInPixels = 50;
                buttonGTmenuStop.heightInPixels = 50;
                buttonGTmenuStop.thickness =0;
                buttonGTmenuStop.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuStop.leftInPixels =120;
                gtMenuPanel.addControl(buttonGTmenuStop);
                var buttonGTmenuPrev = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuPrev",
                    "Content/Common/gtMenuPrev.png"
                ); 
                buttonGTmenuPrev.widthInPixels = 50;
                buttonGTmenuPrev.heightInPixels = 50;
                buttonGTmenuPrev.thickness =0;
                buttonGTmenuPrev.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuPrev.leftInPixels =180;
                gtMenuPanel.addControl(buttonGTmenuPrev);
                var buttonGTmenuNext = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "buttonGTmenuNext",
                    "Content/Common/gtMenuNext.png"
                ); 
                buttonGTmenuNext.widthInPixels = 50;
                buttonGTmenuNext.heightInPixels = 50;
                buttonGTmenuNext.thickness =0;
                buttonGTmenuNext.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_LEFT;
                buttonGTmenuNext.leftInPixels =240;
                gtMenuPanel.addControl(buttonGTmenuNext);
                advancedTextureFullScreen.addControl(gtMenuPanel);
                ///////////////////////////////////////////////////////
                // Adding black screen for autorotation UI//////////////
                ///////////////////////////////////////////////////////
                let blackScreenUI = new BABYLON.GUI.Image("blackScreenUI","Content/Common/blackScreenUI.png");
                blackScreenUI.stretch = BABYLON.GUI.Image.STRETCH_FILL;
                blackScreenUI.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_CENTER;
                blackScreenUI.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_CENTER;
                advancedTextureFullScreen.addControl(blackScreenUI);
                let closeBlackScreenUIBTN = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "closeBlackScreenUIBTN",
                    "Content/Common/closeBlackScreenUIBTN.png"
                ); 
                closeBlackScreenUIBTN.widthInPixels = 100;
                closeBlackScreenUIBTN.heightInPixels = 100;
                closeBlackScreenUIBTN.thickness =0;
                closeBlackScreenUIBTN.horizontalAlignment = BABYLON.GUI.Container.HORIZONTAL_ALIGNMENT_RIGHT;
                closeBlackScreenUIBTN.verticalAlignment = BABYLON.GUI.Container.VERTICAL_ALIGNMENT_TOP;
                closeBlackScreenUIBTN.isVisible =false;
                advancedTextureFullScreen.addControl(closeBlackScreenUIBTN);
                closeBlackScreenUIBTN.onPointerClickObservable.add((evt) => {
                    blackScreenUI.isVisible = false;
                    closeBlackScreenUIBTN.isVisible =false;
                })
                let closeBlackScreenUI = function(){
                    blackScreenUI.isVisible = false;
                };
                //-----------------------------//
                ///////////////////////////
                //Creation Functions///////
                ///////////////////////////
                let CreateBox = function(pos,rot,scaling,material,name){
                    var box = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    box.position = pos;
                    box.rotation = rot;
                    box.scaling = scaling;
                    box.material = material;
                }
                let CreatePlane = function(pos,rot,wt,ht,material,name){
                   var plane = BABYLON.MeshBuilder.CreateGround(name, {width: wt , height: ht}, scene);
                   plane.position = pos;
                   plane.rotation =rot;
                   plane.material = material;
                }
                let CreateHemiSphere = function(pos,rot,diaX,diaY,diaZ,material,name){
                    var hemiSphere = BABYLON.MeshBuilder.CreateSphere(name, {diameterX : diaX,diameterY:diaY,diameterZ:diaZ,arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
                    hemiSphere.position = pos;
                    hemiSphere.rotation = rot;
                    hemiSphere.material = material;
                }
                let CreateSemiCylinder = function(pos,rot,dia,ht,material,name){
                    var semiCylinder = BABYLON.MeshBuilder.CreateCylinder(name, {height : ht,diameter : dia,arc: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
                    semiCylinder.position = pos;
                    semiCylinder.rotation = rot;
                }
                let CreateCircularPlane = function(pos,rot,dia,material,name){
                    var circularPlane = BABYLON.MeshBuilder.CreateDisc(name,{diamter:dia});
                    circularPlane.position = pos;
                    circularPlane.rotation = rot;
                    circularPlane.material = material;
                }

                let CreateCircularGroundPlane = function(pos,rot,dia,material,name){
                    var circularPlane = BABYLON.MeshBuilder.CreateDisc(name,{diameter:dia});
                    circularPlane.position = pos;
                    circularPlane.rotation = rot;
                    circularPlane.material = material;
                    groundList.push(circularPlane);
                }
                let CreateSemiCircularPlane = function(pos,rot,dia,material,name){
                    var semiCircularPlane = BABYLON.MeshBuilder.CreateDisc(name,{radius:dia*0.5,arc :0.5});
                    semiCircularPlane.position = pos;
                    semiCircularPlane.rotation = rot;
                    semiCircularPlane.material = material;
                }

                let CreateSemiCircularGroundPlane = function(pos,rot,dia,material,name){
                    var semiCircularGroundPlane = BABYLON.MeshBuilder.CreateDisc(name,{radius:dia*0.5,arc :0.5});
                    semiCircularGroundPlane.position = pos;
                    semiCircularGroundPlane.rotation = rot;
                    semiCircularGroundPlane.material = material;
                    groundList.push(semiCircularGroundPlane);
                }

                let CreateGroundPlane = function(pos,rot,wt,ht,material,name){
                   var plane = BABYLON.MeshBuilder.CreateGround(name, {width: wt , height: ht}, scene);
                   plane.position = pos;
                   plane.rotation =rot;
                   plane.material = material;
                   groundList.push(plane);
                }

                let CreateCustomGroundPlane = function(shape,holes,material,name){
                    var polygon = BABYLON.MeshBuilder.CreatePolygon(name, {shape:shape, holes:holes, sideOrientation: BABYLON.Mesh.DOUBLESIDE });
                    polygon.material = material;
                    groundList.push(polygon);
                }

                let CreatePhotoFrame = function(pos,rot,wt,ht,material,name){
                    var baseDepth = 0.00002;
                    var edgeDepth = 0.04;
                    var edgeBreadth = 0.04;
                    var baseScaling = new BABYLON.Vector3(wt,ht,baseDepth);
                    var base = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    base.position = new BABYLON.Vector3(pos.x,pos.y,pos.z);
                    base.rotation = rot;
                    base.scaling = baseScaling;
                    base.material = material;
                    var edgeCorrectedPos = new BABYLON.Vector3(pos.x-(edgeDepth*0.5*Math.sin(rot.y)),pos.y,pos.z-(edgeDepth*0.5*Math.cos(rot.y)));
                    var topEdge = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    topEdge.position = new BABYLON.Vector3(edgeCorrectedPos.x,edgeCorrectedPos.y+(ht*0.5),edgeCorrectedPos.z);
                    topEdge.rotation = rot;
                    topEdge.scaling = new BABYLON.Vector3(wt+edgeDepth,edgeBreadth,edgeDepth);
                    topEdge.material = material;
                    var botEdge = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    botEdge.position = new BABYLON.Vector3(edgeCorrectedPos.x,edgeCorrectedPos.y-(ht*0.5),edgeCorrectedPos.z);
                    botEdge.rotation = rot;
                    botEdge.scaling = new BABYLON.Vector3(wt+edgeDepth,edgeBreadth,edgeDepth);
                    botEdge.material = material;
                    var rightEdge = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    rightEdge.position = new BABYLON.Vector3(edgeCorrectedPos.x+(wt*0.5*Math.cos(rot.y)),edgeCorrectedPos.y,edgeCorrectedPos.z-(wt*0.5*Math.sin(rot.y)));
                    rightEdge.rotation = new BABYLON.Vector3(rot.x,rot.y,Math.PI/2);
                    rightEdge.scaling = new BABYLON.Vector3(ht,edgeBreadth,edgeDepth);
                    rightEdge.material = material;
                    var leftEdge = BABYLON.MeshBuilder.CreateBox(name,{size:1},scene);
                    leftEdge.position = new BABYLON.Vector3(edgeCorrectedPos.x-(wt*0.5*Math.cos(rot.y)),edgeCorrectedPos.y,edgeCorrectedPos.z+(wt*0.5*Math.sin(rot.y)));
                    leftEdge.rotation = new BABYLON.Vector3(rot.x,rot.y,Math.PI/2);
                    leftEdge.scaling = new BABYLON.Vector3(ht,edgeBreadth,edgeDepth);
                    leftEdge.material = material;
                    return base;
                }
                let CreateImageFrame = function(pathOfImage,pos,rot,wt,ht,material,name){
                    var baseUI = CreatePhotoFrame(pos,rot,wt,ht,material,name);
                    var baseUITexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                    baseUI,
                    1024,
                    1024
                    );
                    var baseImage = new BABYLON.GUI.Image(name+"-image",pathOfImage);
                    baseUITexture.addControl(baseImage);
                    console.log("image frame created");
                    return baseUI;
                }
                ////////////////////////////////////
                ////////////////////////////////////
                ////---Environment Creation Here---///
                ////////////////////////////////////
                /////////////////
                //Model import///
                /////////////////
                /*BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Model2.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(0,0,0);
                    model.scaling = new BABYLON.Vector3(10,10,10);
                    model.rotation = new BABYLON.Vector3(model.rotation.x,model.rotation.y+Math.PI,model.rotation.z);
                    model.isPickable =false;
                });*/
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "antiqueHall_3.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(0,0,0);
                    model.scaling = new BABYLON.Vector3(-5,5,5);
                    model.rotation = new BABYLON.Vector3(0,Math.PI/2,0);
                    model.isPickable =false;
                });
                CreateBox(new BABYLON.Vector3(-10,6,0),new BABYLON.Vector3(0,Math.PI/2,0),new BABYLON.Vector3(26,12,.01),wallMaterial,"wall");
                CreateBox(new BABYLON.Vector3(10,6,0),new BABYLON.Vector3(0,Math.PI/2,0),new BABYLON.Vector3(26,12,.01),wallMaterial,"wall");
                CreateBox(new BABYLON.Vector3(0,6,13.75),new BABYLON.Vector3(0,0,0),new BABYLON.Vector3(22,12,.01),wallMaterial,"wall");
                CreateBox(new BABYLON.Vector3(0,6,-13.5),new BABYLON.Vector3(0,0,0),new BABYLON.Vector3(22,12,.01),wallMaterial,"wall");
                //CreateBox(new BABYLON.Vector3(0,4,0),new BABYLON.Vector3(0,0,0),new BABYLON.Vector3(16,0.1,16),roofMaterial,"roof");
                CreatePlane(new BABYLON.Vector3(0,-.01,0),new BABYLON.Vector3(0,0,0),20,28,groundZeroMaterial,"groundZero");
                //CreateGroundPlane(new BABYLON.Vector3(0,.15,0),new BABYLON.Vector3(0,0,0),18,26,groundMaterial,"ground1");
                var shape = [ 
		            new BABYLON.Vector3(9.5, 1, 13.5), 
                    new BABYLON.Vector3(-9.5, 1, 13.5), 
                    new BABYLON.Vector3(-9.5, 1, -13.5), 
                    new BABYLON.Vector3(9.5, 1, -13.5)
                ];
                var holes =[];
	            holes[0] = [ 
                        new BABYLON.Vector3(-3.2, 1, 3.2),
                        new BABYLON.Vector3(3.2, 1, 3.2),
                        new BABYLON.Vector3(3.2, 1,-3.2),
                        new BABYLON.Vector3(-3.2, 1, -3.2)
                ];
                CreateCustomGroundPlane(shape,holes,groundMaterial,"ground1");
                //Disable black screen
                closeBlackScreenUI();
                //////////////////////////////////////////////////////////
                //////////////////////////////////////////////////////////
                //////////////////////////////////////////
                ///Guided tours///////////////////////////
                //////////////////////////////////////////
                let gtIsOn = false;
                let gtIndex =0;
                let gtCounter =0;//helps in transitioning smoothly using a frame counter
                let gtFactor =0;//this checks if the current position is for viewing or transitioning
                let gtWaitTime = 5;//current defined wait time in seconds
                let gtPositions = [
                    new BABYLON.Vector3 (0,2,-2.5)
                ];
                let gtWaitTimeFactors = [
                    1
                ];
                let rotDiff = new BABYLON.Vector3(0,0,0);
                let targetLookAt = new BABYLON.Vector3(0,0,0);
                let gtLookAtPositions = [
                    new BABYLON.Vector3(0,2,0)
                ];
                let gtPauseTour =function(){
                    buttonGTmenuPlay.isVisible =true;
                    buttonGTmenuPause.isVisible =false;
                    gtIsOn = false;
                }
                let gtPlayTour = function(){
                    buttonGTmenuPlay.isVisible =false;
                    buttonGTmenuPause.isVisible =true;
                    gtIsOn = true;
                    targetPosition = new BABYLON.Vector3(gtPositions[gtIndex].x,camera.position.y,gtPositions[gtIndex].z);
                    difference = new BABYLON.Vector3(targetPosition.x- camera.position.x,targetPosition.y- camera.position.y,targetPosition.z- camera.position.z);
                    targetLookAt = new BABYLON.Vector3(gtLookAtPositions[gtIndex].x,camera.position.y,gtLookAtPositions[gtIndex].z);
                    gtCounter =0;
                    gtFactor = 1;
                }
                let gtStopTour = function(){
                    buttonGTmenuPlay.isVisible =true;
                    buttonGTmenuPause.isVisible =false;
                    gtIsOn = false;
                    gtIndex =0;
                    gtCounter =0;
                    gtFactor = 1;
                }
                let gtShowMenu = function(){
                    buttonGTmenuClose.isVisible =true;
                    if(gtIsOn){
                        buttonGTmenuPlay.isVisible =false;
                        buttonGTmenuPause.isVisible =true;
                    } else {
                        buttonGTmenuPlay.isVisible =true;
                        buttonGTmenuPause.isVisible =false;
                    }
                    buttonGTmenuStop.isVisible =true;
                    buttonGTmenuPrev.isVisible =true;
                    buttonGTmenuNext.isVisible =true;
                    buttonGTmenu.isVisible = false;
                }
                let gtHideMenu = function(){
                    buttonGTmenu.isVisible =true;
                    buttonGTmenuPlay.isVisible =false;
                    buttonGTmenuPause.isVisible =false;
                    buttonGTmenuStop.isVisible =false;
                    buttonGTmenuPrev.isVisible =false;
                    buttonGTmenuNext.isVisible =false;
                    buttonGTmenuClose.isVisible = false;
                }
                let gtNextTarget = function (){
                    gtIndex++;
                    if(gtIndex>=gtPositions.length){
                        gtIndex =0;
                    }
                    targetPosition = new BABYLON.Vector3(gtPositions[gtIndex].x,camera.position.y,gtPositions[gtIndex].z);
                    difference = new BABYLON.Vector3(targetPosition.x- camera.position.x,targetPosition.y- camera.position.y,targetPosition.z- camera.position.z);
                    targetLookAt = new BABYLON.Vector3(gtLookAtPositions[gtIndex].x,camera.position.y,gtLookAtPositions[gtIndex].z);
                    gtCounter =0;
                    gtFactor = gtWaitTimeFactors[gtIndex];
                }
                let gtPrevTarget = function (){
                    gtIndex--;
                    if(gtIndex<0){
                        gtIndex =gtPositions.length -1;
                    }
                    targetPosition = new BABYLON.Vector3(gtPositions[gtIndex].x,camera.position.y,gtPositions[gtIndex].z);
                    difference = new BABYLON.Vector3(targetPosition.x- camera.position.x,targetPosition.y- camera.position.y,targetPosition.z- camera.position.z);
                    targetLookAt = new BABYLON.Vector3(gtLookAtPositions[gtIndex].x,camera.position.y,gtLookAtPositions[gtIndex].z);
                    gtCounter =0;
                    gtFactor = gtWaitTimeFactors[gtIndex];
                }
                gtHideMenu();
                buttonGTmenu.onPointerClickObservable.add((evt) =>{
                    // opens the gt menu
                    gtShowMenu();
                })
                buttonGTmenuClose.onPointerClickObservable.add((evt) =>{
                    // close the gt menu
                    gtHideMenu();
                })
                buttonGTmenuPlay.onPointerClickObservable.add((evt) =>{
                    //start guided tour
                   gtPlayTour();
                })
                buttonGTmenuPause.onPointerClickObservable.add((evt) =>{
                    //pause guided tour
                    gtPauseTour();
                })
                buttonGTmenuStop.onPointerClickObservable.add((evt) =>{
                    //stop guided tour
                    gtStopTour();
                })
                buttonGTmenuNext.onPointerClickObservable.add((evt) =>{
                    //go to next position
                    gtNextTarget();
                })
                buttonGTmenuPrev.onPointerClickObservable.add((evt) =>{
                    //go to prev position
                    gtPrevTarget();
                })
                /////////////////////////////////////////
                //////////////////////////
                //Footprints behaviours///
                //////////////////////////
                let footprintPositions = [
                    new BABYLON.Vector3(0,2,0)//0
                ];

                let footprintRotations = [
                    new BABYLON.Vector3(0,0,0)//0
                ];
                let ftLookAtPositions = [
                    new BABYLON.Vector3(0,2,0)
                ];
                // Footprint Transition only occurs when guided tour is not happening and the camera is not transitioning
                let inButtonTransition =false;// This indicates if the camera is in transitioning to a footprint
                for(let i=0;i<footprintPositions.length;++i){
                    var standingDistance = 9;
                    var footprintUI = BABYLON.MeshBuilder.CreateBox("box",{size :1},scene);
                    footprintUI.position = new BABYLON.Vector3(footprintPositions[i].x-(standingDistance*Math.sin(footprintRotations[i].y)),footprintPositions[i].y,footprintPositions[i].z-(standingDistance*Math.cos(footprintRotations[i].y)));
                    console.log("("+footprintUI.position.x+","+camera.position.y+","+footprintUI.position.z+")");
                    footprintUI.position.y = .15;
                    footprintUI.rotation = new BABYLON.Vector3(Math.PI/2,footprintRotations[i].y,0);
                    footprintUI.scaling = new BABYLON.Vector3(.6,.6,.0001);
                    var footprintUITexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                    footprintUI,
                    1024,
                    1024
                    );
                    var footprintButton  = BABYLON.GUI.Button.CreateImageOnlyButton(
                        "footprintButton",
                        "Content/Common/footprintIcon.png"
                    );
                    footprintButton.pointerEnterAnimation= function(){};
                    footprintButton.pointerOutAnimation = function(){};
                    footprintButton.pointerUpAnimation = function(){};
                    footprintButton.pointerDownAnimation = function(){};
                    footprintUITexture.addControl(footprintButton);
                    footprintButton.onPointerClickObservable.add((evt)=> {
                        if(!inTransition && !gtIsOn){
                            targetPosition = new BABYLON.Vector3(footprintPositions[i].x-(standingDistance*Math.sin(footprintRotations[i].y)),camera.position.y,footprintPositions[i].z-(standingDistance*Math.cos(footprintRotations[i].y)));
                            difference = new BABYLON.Vector3(targetPosition.x- camera.position.x,targetPosition.y- camera.position.y,targetPosition.z- camera.position.z);
                            targetLookAt = new BABYLON.Vector3(ftLookAtPositions[i].x,camera.position.y,ftLookAtPositions[i].z);    
                            inButtonTransition =true;
                        }
                    })
                }
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Pedestal.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(-8.6,0,5);
                    model.scaling = new BABYLON.Vector3(3,2,5.5);
                    model.rotation = new BABYLON.Vector3(0,0,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "namePlate.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(-7.75,2.45,5);
                    model.scaling = new BABYLON.Vector3(20,20,20);
                    model.rotation = new BABYLON.Vector3(0,Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Pedestal.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,0,-3.75);
                    model.scaling = new BABYLON.Vector3(2,2,2);
                    model.rotation = new BABYLON.Vector3(0,0,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "namePlate.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.1,2.45,-3.75);
                    model.scaling = new BABYLON.Vector3(10,10,10);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Pedestal.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,0,3);
                    model.scaling = new BABYLON.Vector3(2,2,2);
                    model.rotation = new BABYLON.Vector3(0,0,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "namePlate.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.1,2.45,3);
                    model.scaling = new BABYLON.Vector3(10,10,10);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Pedestal.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,0,9.25);
                    model.scaling = new BABYLON.Vector3(2,2,2);
                    model.rotation = new BABYLON.Vector3(0,0,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "namePlate.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.1,2.45,9.25);
                    model.scaling = new BABYLON.Vector3(10,10,10);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Camel.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,2.4,9.25);
                    model.scaling = new BABYLON.Vector3(1,1,1);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Rabbit.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,2.4,3);
                    model.scaling = new BABYLON.Vector3(1,1,1);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Gajasimbha.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(8.7,2.4,-3.75);
                    model.scaling = new BABYLON.Vector3(.5,.5,.5);
                    model.rotation = new BABYLON.Vector3(0,-Math.PI/2,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "Dog.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(-8.6,2.38,5);
                    model.scaling = new BABYLON.Vector3(2,2,2);
                    model.rotation = new BABYLON.Vector3(0,0,0);
                    model.isPickable =false;
                });
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "CM281.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(0,.25,0);
                    model.scaling = new BABYLON.Vector3(2,2,2);
                    model.rotation = new BABYLON.Vector3(0,Math.PI,0);
                    model.isPickable =false;
                });
                
                const modelPie = [BABYLON.emptyMesh,];
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "pie.glb").then((result) => {
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        result.meshes[i].isVisible = false;
                        modelPie[i] = result.meshes[i];
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    const model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(-3,2,12);
                    model.scaling = new BABYLON.Vector3(-8,8,8);
                    model.rotation = new BABYLON.Vector3(0,5*Math.PI/4,0);
                    model.isPickable =false;
                    model.isVisible = false;
                    //modelPie=result.meshes;
                });
                const modelBar = [BABYLON.emptyMesh,];
                BABYLON.SceneLoader.ImportMeshAsync("", "Models/", "bar.glb").then((result) => {
                    //modelBar = new BABYLON.Mesh(result.meshes.length);
                    for(let i=0;i<result.meshes.length;++i){
                        result.meshes[i].isPickable = false;
                        result.meshes[i].isVisible = false;
                        modelBar[i] = result.meshes[i];
                        console.log("mesh name : "+result.meshes[i].name);
                    }
                    var model = result.meshes[0];
                    model.position =  new BABYLON.Vector3(-7,2,12);
                    model.scaling = new BABYLON.Vector3(-8,8,8);
                    model.rotation = new BABYLON.Vector3(0,3*Math.PI/4,0);
                    model.isPickable =false;
                });
                CreateImageFrame("Content/9.png",new BABYLON.Vector3(-9.85,6.5,-5),new BABYLON.Vector3(0,-Math.PI/2,0),3,3,transparentMaterial,"2");
                CreateImageFrame("Content/10.png",new BABYLON.Vector3(-9.85,2.5,-5),new BABYLON.Vector3(0,-Math.PI/2,0),3,3,transparentMaterial,"2");
                CreateImageFrame("Content/11.png",new BABYLON.Vector3(-9.85,2.5,-9),new BABYLON.Vector3(0,-Math.PI/2,0),3,3,transparentMaterial,"2");
                CreateImageFrame("Content/12.png",new BABYLON.Vector3(-9.85,6.5,-9),new BABYLON.Vector3(0,-Math.PI/2,0),3,3,transparentMaterial,"2");
                var articleName = CreateImageFrame("Content/ArticleName.png",new BABYLON.Vector3(0,6.5,0),new BABYLON.Vector3(0,0,0),1.2,.5,woodMaterial,"1");
                var infoPanel = CreateImageFrame("Content/InfoCatalog.png",new BABYLON.Vector3(2.75,3.75,0),new BABYLON.Vector3(0,0,0),.9,.9,woodMaterial,"1");
                infoPanel.isVisible = false;
                var locPanel = CreateImageFrame("Content/InfoLocation.png",new BABYLON.Vector3(-2.75,3.75,0),new BABYLON.Vector3(0,0,0),.9,.9,woodMaterial,"1");
                locPanel.isVisible = false;
                var button_InfoPanel = BABYLON.MeshBuilder.CreateBox("box",{size :1},scene);
                button_InfoPanel.position = new BABYLON.Vector3(2.75,3,0);
                console.log("("+button_InfoPanel.position.x+","+camera.position.y+","+button_InfoPanel.position.z+")");
                button_InfoPanel.rotation = new BABYLON.Vector3(0,0,0);
                button_InfoPanel.scaling = new BABYLON.Vector3(.3,.3,.0001);
                var button_InfoPanelTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                button_InfoPanel,
                1024,
                1024
                );
                var button_Info  = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "button_Info",
                    "Content/ButtonInfo.png"
                );
                button_Info.pointerEnterAnimation= function(){};
                button_Info.pointerOutAnimation = function(){};
                button_Info.pointerUpAnimation = function(){};
                button_Info.pointerDownAnimation = function(){};
                button_Info.onPointerClickObservable.add((evt)=> {
                    infoPanel.isVisible = !infoPanel.isVisible;
                })
                button_InfoPanelTexture.addControl(button_Info);    
                //
                var button_LocPanel = BABYLON.MeshBuilder.CreateBox("box",{size :1},scene);
                button_LocPanel.position = new BABYLON.Vector3(-2.75,3,0);
                console.log("("+button_LocPanel.position.x+","+camera.position.y+","+button_LocPanel.position.z+")");
                button_LocPanel.rotation = new BABYLON.Vector3(0,0,0);
                button_LocPanel.scaling = new BABYLON.Vector3(.3,.3,.0001);
                var button_LocPanelTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                button_LocPanel,
                1024,
                1024
                );
                var button_Loc  = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "button_Loc",
                    "Content/ButtonLoc.png"
                );
                button_Loc.pointerEnterAnimation= function(){};
                button_Loc.pointerOutAnimation = function(){};
                button_Loc.pointerUpAnimation = function(){};
                button_Loc.pointerDownAnimation = function(){};
                button_Loc.onPointerClickObservable.add((evt)=> {
                    locPanel.isVisible = !locPanel.isVisible;
                })
                button_LocPanelTexture.addControl(button_Loc); 
                var chart2D = CreateImageFrame("Content/Chart-1.png",new BABYLON.Vector3(-5,5.2,13.75),new BABYLON.Vector3(0,0,0),3.6,4.8,woodMaterial,"1");
                chart2D.isVisible = false;
                var pie2D = CreateImageFrame("Content/Chart-2.png",new BABYLON.Vector3(-5,5.2,13.75),new BABYLON.Vector3(0,0,0),3.6,4.8,woodMaterial,"1");
                pie2D.isVisible = false;
                var statsUI = CreateImageFrame("Content/StatsUI.png",new BABYLON.Vector3(-5,2.5,13.6),new BABYLON.Vector3(0,0,0),1.2,.5,woodMaterial,"1");
                var button_chart2DPanel = BABYLON.MeshBuilder.CreateBox("box",{size :1},scene);
                button_chart2DPanel.position = new BABYLON.Vector3(-5.25,2,13.6);
                console.log("("+button_chart2DPanel.position.x+","+camera.position.y+","+button_chart2DPanel.position.z+")");
                button_chart2DPanel.rotation = new BABYLON.Vector3(0,0,0);
                button_chart2DPanel.scaling = new BABYLON.Vector3(.5,.5,.0001);
                var button_chart2DPanelTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                button_chart2DPanel,
                1024,
                1024
                );
                var button_chart2D  = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "button_chart2D",
                    "Content/BTN_Chart2D.png"
                );
                button_chart2D.pointerEnterAnimation= function(){};
                button_chart2D.pointerOutAnimation = function(){};
                button_chart2D.pointerUpAnimation = function(){};
                button_chart2D.pointerDownAnimation = function(){};
                button_chart2D.onPointerClickObservable.add((evt)=> {
                    chart2D.isVisible = true;
                    for(let i=0;i<modelBar.length;++i){
                        modelBar[i].isVisible = true;
                    }
                    pie2D.isVisible = false;
                    for(let i=0;i<modelBar.length;++i){
                        modelPie[i].isVisible = false;
                    }
                })
                button_chart2DPanelTexture.addControl(button_chart2D);
                //
                var button_pie2DPanel = BABYLON.MeshBuilder.CreateBox("box",{size :1},scene);
                button_pie2DPanel.position = new BABYLON.Vector3(-4.75,2,13.6);
                console.log("("+button_pie2DPanel.position.x+","+camera.position.y+","+button_pie2DPanel.position.z+")");
                button_pie2DPanel.rotation = new BABYLON.Vector3(0,0,0);
                button_pie2DPanel.scaling = new BABYLON.Vector3(.5,.5,.0001);
                var button_pie2DPanelTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(
                button_pie2DPanel,
                1024,
                1024
                );
                var button_pie2D  = BABYLON.GUI.Button.CreateImageOnlyButton(
                    "button_pie2D",
                    "Content/BTN_Pie2D.png"
                );
                button_pie2D.pointerEnterAnimation= function(){};
                button_pie2D.pointerOutAnimation = function(){};
                button_pie2D.pointerUpAnimation = function(){};
                button_pie2D.pointerDownAnimation = function(){};
                button_pie2D.onPointerClickObservable.add((evt)=> {
                    pie2D.isVisible = true;
                    for(let i=0;i<modelBar.length;++i){
                        modelPie[i].isVisible = true;
                    }
                    chart2D.isVisible = false;
                    for(let i=0;i<modelBar.length;++i){
                        modelBar[i].isVisible = false;
                    }

                })
                button_pie2DPanelTexture.addControl(button_pie2D); 
                //--------------//
                /////////////////////////////////////////
                //----NAVIGATING WITH CLICKS----------///
                /////////////////////////////////////////
                //Creating a crosshair
                let crossHair = BABYLON.Mesh.CreateBox("crosshairBox", 1,scene);
                crossHair.scaling.z =0.01;
                crossHair.material = new BABYLON.StandardMaterial("crossHairmaterial", scene);
                crossHair.material.diffuseTexture = new BABYLON.Texture("Content/Common/Crosshairs/crosshair118.png", scene);
                crossHair.material.diffuseColor = new BABYLON.Color3(0,0,0);
                crossHair.material.diffuseTexture.hasAlpha = true;
                crossHair.position = new BABYLON.Vector3(0, 0, -0.1);
                crossHair.isPickable =false;
                scene.onPointerDown = function (evt, pickResult) {
                    //rotation constraint
                    //camera.rotation = new BABYLON.Vector3(Math.min(Math.max(camera.rotation.x, minXvalue), maxXvalue),camera.rotation.y,0);
                    // if the click hits the ground object, we change the crosshair position
                    if (groundList.includes(pickResult.pickedMesh)) {
                        movingAction =true;// as the pointer is hovering over a standing ground plane it might be a moving action by the user
                        trackingMesh = pickResult.pickedMesh;
                        pointerPos.x = pickResult.pickedPoint.x;
                        pointerPos.y = pickResult.pickedPoint.z;
                        //console.log("picked point(x,z) :: "+ pickResult.pickedPoint.x +","+ pickResult.pickedPoint.z);
                    } else {
                        movingAction =false;
                        trackingMesh = emptyMesh;
                    }
                };
                scene.onPointerUp = function (evt, pickResult) {
                    //rotation constraint
                    //camera.rotation = new BABYLON.Vector3(Math.min(Math.max(camera.rotation.x, minXvalue), maxXvalue),camera.rotation.y,0);
                    // if the click hits the ground object, we change the crosshair position
                    if (pickResult.pickedMesh == trackingMesh && movingAction ) {
                        var pickResultVector = new BABYLON.Vector2(pickResult.pickedPoint.x,pickResult.pickedPoint.z);
                        var distance = pickResultVector.subtract(pointerPos).length();
                        //IF the distance is less than the threshold distance and guided tour is not active then start transition to the new position
                        if(distance<.5 && !gtIsOn){
                            targetPosition = new BABYLON.Vector3(pickResult.pickedPoint.x,camera.position.y,pickResult.pickedPoint.z);
                            difference = new BABYLON.Vector3(targetPosition.x-camera.position.x,targetPosition.y-camera.position.y,targetPosition.z-camera.position.z);
                            movingAction = false;
                            inTransition =true;//sets transition to new position 
                            trackingMesh = emptyMesh;
                        }
                    }
                };   
                scene.onPointerMove = function (evt,pickResult) {
                    //rotation constraint
                    //camera.rotation = new BABYLON.Vector3(Math.min(Math.max(camera.rotation.x, minXvalue), maxXvalue),camera.rotation.y,0);
                    var ray = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), null);
                    var hit = scene.pickWithRay(ray);
                    var pickedMesh = hit.pickedMesh;
                    var pickedsPoint = hit.pickedPoint;
                    if(pickedsPoint == null){return;}
                    crossHair.position.x = pickedsPoint.x;
                    crossHair.position.y = pickedsPoint.y;
                    crossHair.position.z = pickedsPoint.z;
                    var v1 = new BABYLON.Vector2(crossHair.position.x,crossHair.position.z);
                    var v2 = new BABYLON.Vector2(camera.position.x,camera.position.z);
                    var distanceCamCrosshair = v1.subtract(v2).length();
                    if(distanceCamCrosshair>maxDistance){
                        factor=maxScale;
                        crossHair.scaling =new BABYLON.Vector3(factor*.1,factor*.1,factor*0.001);
                    }
                    else if(distanceCamCrosshair>minDistance){
                        factor =minScale +((maxScale-minScale)*(distanceCamCrosshair-minDistance)/(maxDistance-minDistance));
                        crossHair.scaling =new BABYLON.Vector3(factor*.1,factor*.1,factor*0.001);
                    }else {
                        factor=minScale;
                        crossHair.scaling =new BABYLON.Vector3(factor*.1,factor*.1,factor*0.001);
                    }
                    if(groundList.includes(pickedMesh)){
                        crossHair.position.y = pickedsPoint.y+.1;
                        crossHair.rotation = new BABYLON.Vector3(Math.PI/2,0,0);
                    } else if(pickedMesh.name =="roof"){
                        crossHair.position.y = pickedsPoint.y-.1;
                        crossHair.rotation = new BABYLON.Vector3(-Math.PI/2,0,0);
                    } else if(pickedMesh.name =="groundZero"){
                        crossHair.position.y = pickedsPoint.y+.1;
                        crossHair.rotation = new BABYLON.Vector3(Math.PI/2,0,0);
                    } 
                    else {
                        crossHair.rotation = pickedMesh.rotation;
                    }
                };
                //-----------////
                //-----------////
                /////////////////////////////////////////////
                /////Variables for movement and tours////////
                /////////////////////////////////////////////
                let inTransition = false;
                let minDistanceTransition = 0.01;
                let targetPosition = new BABYLON.Vector3(5.0,5.0,5.0);
                let moveSpeed = .01;
                let difference = new BABYLON.Vector3(0.0,0.0,0.0);
                //this function returns distance between two vectors
                let distanceBWVectors = function(a, b) {
                    var distance = 0.0;
                    var dx = b.x-a.x;
                    var dy = b.y-a.y;
                    var dz = b.z-a.z;
                    distance = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2)+Math.pow(dz,2));
                    return distance;
                } 
                //This function is used in minimap positioning
                let setIndicatorPosition = function(){
                    var x = camera.position.x;
                    var y = camera.position.z;
                    playerIndicator.leftInPixels = factorX +playerIndicator.widthInPixels+ x*conversionFactor;
                    playerIndicator.topInPixels = factorY-playerIndicator.heightInPixels - y*conversionFactor;
                }
                //This function is used for minimap rotation
                let setIndicatorRotation = function(){
                    playerIndicator.rotation = camera.rotation.y;
                }
                scene.registerBeforeRender(function () {
                    setIndicatorRotation();
                    if(gtIsOn){
                        if(distanceBWVectors(camera.position,targetPosition)<minDistance){
                            camera.position = targetPosition;
                            camera.setTarget(new BABYLON.Vector3(targetLookAt.x,targetLookAt.y,targetLookAt.z));
                            gtCounter++;
                            setIndicatorPosition();
                            if(gtCounter >gtFactor*gtWaitTime*60){
                                gtNextTarget();
                            }
                        } else {
                            camera.position = new BABYLON.Vector3((moveSpeed*difference.x)+ camera.position.x,camera.position.y,(moveSpeed*difference.z)+ camera.position.z); 
                            //camera.setTarget(​​new BABYLON.Vector3(targetLookAt.x,targetLookAt.y,targetLookAt.z));
                            camera.setTarget(new BABYLON.Vector3(targetLookAt.x,targetLookAt.y,targetLookAt.z));
                            setIndicatorPosition();
                        }
                    }else  if(inButtonTransition){
                        if(distanceBWVectors(camera.position,targetPosition)<minDistance){
                            inButtonTransition = false;
                            camera.position = targetPosition;
                            camera.setTarget(new BABYLON.Vector3(targetLookAt.x,targetLookAt.y,targetLookAt.z));
                            setIndicatorPosition();
                        } else {
                            camera.position = new BABYLON.Vector3((moveSpeed*difference.x)+ camera.position.x,camera.position.y,(moveSpeed*difference.z)+ camera.position.z);
                            camera.setTarget(new BABYLON.Vector3(targetLookAt.x,targetLookAt.y,targetLookAt.z));
                            setIndicatorPosition();
                        }
                    } 
                    else if(inTransition){
                        camera.position = new BABYLON.Vector3((moveSpeed*difference.x)+ camera.position.x,camera.position.y,(moveSpeed*difference.z)+ camera.position.z);
                        setIndicatorPosition();
                        if(distanceBWVectors(camera.position,targetPosition)<minDistance){
                            inTransition = false;
                            camera.position = targetPosition;
                            setIndicatorPosition();
                        }
                    }
                });
                //-----------////
                //////////////////////////////////////
                // ENABLE VR EXPERIENCE///////////////
                //////////////////////////////////////
                var environment = scene.createDefaultEnvironment({ enableGroundShadow: true, groundYBias: 2 });
                environment.setMainColor(BABYLON.Color3.FromHexString("#74b9ff"))
                var xr = await scene.createDefaultXRExperienceAsync({
                   floorMeshes: [scene.getMeshByName("ground1"),scene.getMeshByName("ground2"),scene.getMeshByName("ground3"),scene.getMeshByName("ground4"),scene.getMeshByName("ground5"),scene.getMeshByName("ground6")] 
                });
                const teleportation = xr.teleportation;
                teleportation.teleportationEnabled =true;
                xr.baseExperience.sessionManager.onXRSessionEnded.add(()=>{
                    crossHair.isVisible=true;
                });
                let vrHeight = 2.75;
                let vrCam = xr.baseExperience.camera;
                xr.baseExperience.onStateChangedObservable.add((state)=>{
                    if(state === BABYLON.WebXRState.IN_XR){
                       vrCam.position.y = vrHeight;
                    }
                });
                vrCam.onAfterCameraTeleport.add((targetPosition) => {
                    vrCam.position.y = vrHeight;
                });
                xr.input.onControllerAddedObservable.add((controller) => {
                   controller.onMotionControllerInitObservable.add((motionController) => {
                        motionController.onModelLoadedObservable.add(()=>{
                            motionController.rootMesh.isPickable =false;
                            crossHair.isVisible=false;
                        });
                        if (motionController.handness === 'right') {
                            const xr_ids = motionController.getComponentIds();
                            let triggerComponent = motionController.getComponent(xr_ids[0]);//xr-standard-trigger
                            triggerComponent.onButtonStateChangedObservable.add(() => {
                                if (triggerComponent.pressed) {
                                    console.log("TriggerComponent Right Pressed");
                                }
                            });
                            let squeezeComponent = motionController.getComponent(xr_ids[1]);//xr-standard-squeeze
                            squeezeComponent.onButtonStateChangedObservable.add(() => {
                                if (squeezeComponent.pressed) {
                                    console.log("SqueezeComponent Right Pressed");
                                }
                            });
                            let thumbstickComponent = motionController.getComponent(xr_ids[2]);//xr-standard-thumbstick
                            thumbstickComponent.onButtonStateChangedObservable.add(() => {
                                if (thumbstickComponent.pressed) {
                                    console.log("ThumbComponent Right Pressed");
                                }
                            });
                            thumbstickComponent.onAxisValueChangedObservable.add((axes) => {
                                console.log("Axis values changed Right");
                            });
                            let abuttonComponent = motionController.getComponent(xr_ids[3]);//a-button
                            abuttonComponent.onButtonStateChangedObservable.add(() => {
                                if (abuttonComponent.pressed) {
                                    console.log("ButtonA Right Pressed");
                                    camera.fov = fov_min;
                                    zoomedIn =true;
                                }
                            });
                            let bbuttonComponent = motionController.getComponent(xr_ids[4]);//b-button
                            bbuttonComponent.onButtonStateChangedObservable.add(() => {
                                if (bbuttonComponent.pressed) {
                                    console.log("ButtonB Right Pressed");
                                    camera.fov = fov_max;
                                    zoomedIn =false;
                                }
                            });
                        }
                        if (motionController.handness === 'left') {
                            const xr_ids = motionController.getComponentIds();
                            let triggerComponent = motionController.getComponent(xr_ids[0]);//xr-standard-trigger
                            triggerComponent.onButtonStateChangedObservable.add(() => {
                                if (triggerComponent.pressed) {
                                    console.log("TriggerComponent Left Pressed");
                                }
                            });
                            let squeezeComponent = motionController.getComponent(xr_ids[1]);//xr-standard-squeeze
                            squeezeComponent.onButtonStateChangedObservable.add(() => {
                                if (squeezeComponent.pressed) {
                                    console.log("SqueezeComponent Left Pressed");   
                                }
                            });
                            let thumbstickComponent = motionController.getComponent(xr_ids[2]);//xr-standard-thumbstick
                            thumbstickComponent.onButtonStateChangedObservable.add(() => {
                                if (thumbstickComponent.pressed) {
                                    console.log("ThumbComponent Left Pressed");
                                }
                            });
                            thumbstickComponent.onAxisValueChangedObservable.add((axes) => {
                                console.log("Axis values changed Left");
                            });
                            let xbuttonComponent = motionController.getComponent(xr_ids[3]);//x-button
                            xbuttonComponent.onButtonStateChangedObservable.add(() => {
                                if (xbuttonComponent.pressed) {
                                    console.log("Button X Left Pressed");  
                                }
                            });
                            let ybuttonComponent = motionController.getComponent(xr_ids[4]);//y-button
                            ybuttonComponent.onButtonStateChangedObservable.add(() => {
                                if (ybuttonComponent.pressed) {
                                    console.log("Button Y Left Pressed");  
                                }
                            });
                        }
                   })
                });
                return scene;
            };
            window.initFunction = async function() {        
                var asyncEngineCreation = async function() {
                    try {
                        return createDefaultEngine();
                    } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                    }
                }
                window.engine = await asyncEngineCreation();
                if (!engine) throw 'engine should not be null.';
                window.scene = await createScene();
            };
            initFunction().then(() => {sceneToRender = scene        
                engine.runRenderLoop(function () {
                    if (sceneToRender && sceneToRender.activeCamera) {
                        sceneToRender.render();
                    }
                });
            });
            // Resize
            window.addEventListener("resize", function () {
                engine.resize();
            });
        </script>
    </body>
</html>
